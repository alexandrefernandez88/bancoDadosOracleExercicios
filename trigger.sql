TRIGGER - GATILHO (DISPARADO DE ACORDO COM ALGUM EVENTO)
    DDL 
    LOGON/LOGOFF
    STARTUP / SHUTDOWN
    **** TABLE ****

. SEMPRE ESTÁ LIGADO A UMA TABELA
. EVENTOS: INSERT, UPDATE, DELETE
. BEFORE / AFTER

NÃO::::
--------
    X UTILIZAR SELECT, INSERT, UPDATE, DELETE NO TRIGGER DA PRÓPRIA TABELA
    X MUTANT TRIGGER = TRIGGER CÍCLICO -> TAB1 -> TAB2 -> TAB1
    X COMMIT, ROLLBACK OU SAVEPOINT

1. FAÇA UM TRIGGER QUE AO SE DELETAR UM CLIENTE, INSIRA NUMA TABELA DE LOG_XCLIENTE 
   TODOS OS ATRIBUTOS DO REGISTRO DELETADO OU ALTERADO, ACRECENTANDO O USUÁRIO QUE 
   FEZ A OPERAÇÃO (USER) E A DATA (SYSDATE). 
   VOCÊ TERÁ QUE CRIAR A TABELA DE LOG.

CREATE TABLE LOG_XCLIENTE
AS SELECT * FROM XCLIENTE WHERE 1=2;

DESC LOG_XCLIENTE

ALTER TABLE LOG_XCLIENTE
ADD (LOG_SEQ NUMBER(10) PRIMARY KEY,
     LOG_USUARIO VARCHAR2(30),
     LOG_DATA DATE)

CREATE SEQUENCE SEQ_LOG_CLIENTE
START WITH 1
INCREMENT BY 1

SELECT * FROM LOG_XCLIENTE
ORDER BY LOG_DATA
DESC LOG_XCLIENTE

----------------------

CREATE OR REPLACE TRIGGER TG_XCLIENTE
AFTER UPDATE OR DELETE
ON XCLIENTE
FOR EACH ROW
BEGIN
   INSERT INTO LOG_XCLIENTE
      (CLI_COD,
      CID_COD,
      CLI_NOME,
      CLI_CPF,
      LOG_SEQ,
      LOG_USUARIO,
      LOG_DATA)
   VALUES
      (:OLD.CLI_COD,
       :OLD.CID_COD,
       :OLD.CLI_NOME,
       :OLD.CLI_CPF,
       SEQ_LOG_CLIENTE.NEXTVAL,
       USER,
       SYSDATE
      );

END;

-- ----------- TESTANDO
SELECT * FROM LOG_XCLIENTE
SELECT * FROM XCLIENTE ORDER BY CLI_COD DESC

UPDATE XCLIENTE
SET CLI_NOME = 'EXEMPLO DE AULA'
WHERE CLI_COD = 10

SELECT * FROM LOG_XCLIENTE

SELECT * FROM XCLIENTE WHERE CLI_COD=10

UPDATE XCLIENTE
SET CLI_NOME = 'TESTE DO YGOR 2222222', CLI_CPF='11111111'
WHERE CLI_COD = 70

SELECT * FROM XCLIENTE ORDER BY CLI_COD DESC

SELECT * FROM LOG_XCLIENTE

DELETE FROM XCLIENTE WHERE CLI_COD = 69;

SELECT * FROM XCLIENTE ORDER BY CLI_COD DESC

UPDATE XCLIENTE
SET CLI_NOME = 'YGOR JOSE DA COSTA', CLI_CPF='11111111'
WHERE CLI_COD = 70

SELECT * FROM LOG_XCLIENTE


2. FAÇA UM TRIGGER QUE PROIBA QUALQUER OPERAÇÃO DML NA TABELA DE NOTA DAS 20:00 AS 06:00 
   E AOS DOMINGOS O DIA TODO.

CREATE OR REPLACE TRIGGER TG_NOTA
BEFORE INSERT OR UPDATE OR DELETE
ON XNOTA
FOR EACH ROW
BEGIN
   IF (TO_CHAR(SYSDATE,'HH24MI') < '0600' OR TO_CHAR(SYSDATE,'HH24MI') > '2000') THEN
       RAISE_APPLICATION_ERROR(-20003,'HORARIO NÃO PERMITIDO....');
   END IF;
   IF (TO_CHAR(SYSDATE,'d') = 1) THEN
       RAISE_APPLICATION_ERROR(-20002,'DOMINGO NÃO PERMITIDAS ALTERAÇÕES....');
   END IF;
END;

--- TESTANDO

SELECT TO_CHAR(SYSDATE,'HH24MI') FROM DUAL

DELETE FROM XNOTA WHERE NOT_NUM = 1

UPDATE XNOTA SET NOT_DATA = SYSDATE WHERE NOT_NUM = 1
INSERT INTO XNOTA VALUES (99,1,SYSDATE,99);
DELETE FROM XNOTA WHERE NOT_NUM = 99
DESC XNOTA


3. FAÇA UM TRIGGER QUE QUANDO O ESTOQUE DO XPRODUTO ESTIVER ABAIXO DO MÍNIMO, 
   GERE UM PEDIDO DESTE XPRODUTO COM A QUANTIDADE PARA ATINGIR O ESTOQUE MÁXIMO.

CREATE SEQUENCE SEQ_PED
START WITH 1
INCREMENT BY 1;

CREATE OR REPLACE TRIGGER TG_PEDIDO
AFTER UPDATE OF PRO_ESTOQUE
ON XPRODUTO
FOR EACH ROW
DECLARE
BEGIN
   IF :NEW.PRO_ESTOQUE < :NEW.PRO_ESTMIN THEN
      INSERT INTO XPEDIDO (PED_COD,PED_DATA,PRO_COD,PED_QTDE)
      VALUES (SEQ_PED.NEXTVAL,SYSDATE,:NEW.PRO_COD,:NEW.PRO_ESTMAX - :NEW.PRO_ESTOQUE);
   END IF;
END;

-- TESTANDO

SELECT * FROM XPRODUTO

UPDATE XPRODUTO 
SET PRO_ESTOQUE = 5 WHERE PRO_COD IN (1,2);

SELECT * FROM XPEDIDO

-- 

4. Na tabela de XCLIENTE:
   a. proibir um CPF incorreto através de uma função pronta chamada V_CPF no public
      que retorna 'S' se o CPF está correto e 'N' se está incorreto.
   b. proibir que a dívida da pessoa fique maior que o limite

create or replace FUNCTION V_CPF(CAMPO CHAR) RETURN CHAR 
                                                                              
IS
                                                                             
   I  NUMBER;
   D  NUMBER;
   D1 NUMBER;
   D2 NUMBER;
   R  NUMBER;
   AUX VARCHAR2(20);
   RETORNO CHAR;

BEGIN

   RETORNO := 'N';
   D1      := 0  ;
   D2      := 0  ; 
   AUX     := '' ;

   FOR I IN 1..LENGTH(CAMPO) LOOP
      IF SUBSTR(CAMPO,I,1) IN ('0','1','2','3','4','5','6','7','8','9') THEN 
         AUX := AUX || SUBSTR(CAMPO,I,1);
      END IF; 
   END LOOP;

   IF (LENGTH(LTRIM(RTRIM(AUX)))=11) THEN

      FOR I IN 1..9 LOOP
         D1:=D1+((11-I)*TO_NUMBER(SUBSTR(AUX,I,1)));
         D2:=D2+((12-I)*TO_NUMBER(SUBSTR(AUX,I,1)));
      END LOOP;

      R := MOD(D1,11);

      IF (R<2) THEN
         D := 0;
      ELSE
         D := 11 - R;
      END IF;

      D2 := D2 + (2*D);
      R  := MOD(D2,11);
      D  := D*10;

      IF (R >= 2) THEN 
         D := D + (11-R);
      END IF;

      IF (D = TO_NUMBER(SUBSTR(AUX,10,2))) THEN 
         RETORNO := 'S';
      END IF;

   END IF;

   RETURN(RETORNO);

END V_CPF;

-- ----------------------

CREATE OR REPLACE TRIGGER TG_XCLIENTE
BEFORE INSERT OR UPDATE ON XCLIENTE
FOR EACH ROW
DECLARE 
   VR CHAR(1);
BEGIN
   SELECT V_CPF(:NEW.CLI_CPF) INTO VR FROM DUAL;
   IF VR = 'N' THEN
      RAISE_APPLICATION_ERROR(-20100,'CPF INVÁLIDO...');
   END IF;
   IF :NEW.CLI_DIVIDA > :NEW.CLI_LIMITE THEN
      RAISE_APPLICATION_ERROR(-20101,'LIMITE INSIFICIENTE...');
   END IF;
END;

-- TESTANDO
UPDATE XCLIENTE SET CLI_CPF = '787878'
WHERE CLI_COD = 1;
UPDATE XCLIENTE SET CLI_CPF = '11111111111'
WHERE CLI_COD = 1;

UPDATE XCLIENTE SET CLI_DIVIDA = 99999
WHERE CLI_COD = 1;



5. Decrementar a dívida da pessoa quando um título/duplicata for pago

CREATE OR REPLACE TRIGGER TG_BX_DUP
AFTER DELETE OR UPDATE OF DUP_DTPAGTO ON XDUPLICATA
FOR EACH ROW
BEGIN

   IF UPDATING THEN
      IF :OLD.DUP_DTPAGTO IS NULL AND :NEW.DUP_DTPAGTO IS NOT NULL THEN
         UPDATE XCLIENTE
         SET CLI_DIVIDA = CLI_DIVIDA - :NEW.DUP_VALOR
         WHERE CLI_COD = (SELECT CLI_COD FROM XNOTA WHERE NOT_NUM = :NEW.NOT_NUM);
      END IF;

      IF :OLD.DUP_DTPAGTO IS NOT NULL AND :NEW.DUP_DTPAGTO IS NULL THEN
         UPDATE XCLIENTE
         SET CLI_DIVIDA = CLI_DIVIDA + :NEW.DUP_VALOR
         WHERE CLI_COD = (SELECT CLI_COD FROM XNOTA WHERE NOT_NUM = :NEW.NOT_NUM);
      END IF;
   ELSE
      IF :OLD.DUP_DTPAGTO IS NULL THEN
         UPDATE XCLIENTE
         SET CLI_DIVIDA = CLI_DIVIDA - :OLD.DUP_VALOR
         WHERE CLI_COD = (SELECT CLI_COD FROM XNOTA WHERE NOT_NUM = :OLD.NOT_NUM);
      END IF;   
   END IF;

END;

-- TESTANDO
SELECT * FROM XCLIENTE WHERE CLI_COD = 1

SELECT * FROM XDUPLICATA WHERE NOT_NUM IN (SELECT NOT_NUM FROM XNOTA WHERE CLI_COD =1)

UPDATE XDUPLICATA
SET DUP_DTPAGTO = SYSDATE
WHERE NOT_NUM = 1 AND DUP_SEQ = 1;

SELECT * FROM XCLIENTE WHERE CLI_COD = 1

6. Na tabela de ITENS DA NOTA
   a. atualizar o estoque do XPRODUTO quando for inserido, alterado ou excluído 
   um item.

CREATE OR REPLACE TRIGGER TG_BAIXA
AFTER INSERT OR UPDATE OR DELETE
ON XITEMNOTA
FOR EACH ROW
BEGIN
   IF INSERTING THEN
      UPDATE XPRODUTO
      SET PRO_ESTOQUE = PRO_ESTOQUE - :NEW.IT_QUANT
      WHERE PRO_COD = :NEW.PRO_COD;
   END IF;
   IF DELETING THEN
      UPDATE XPRODUTO
      SET PRO_ESTOQUE = PRO_ESTOQUE + :OLD.IT_QUANT
      WHERE PRO_COD = :OLD.PRO_COD;
   END IF;
   IF UPDATING THEN
      IF :OLD.PRO_COD <> :NEW.PRO_COD THEN
         RAISE_APPLICATION_ERROR(-20001,'NAO PODE ALTERAR O CODIGO.');
      END IF;
      UPDATE XPRODUTO
      SET PRO_ESTOQUE = PRO_ESTOQUE + :OLD.IT_QUANT - :NEW.IT_QUANT
      WHERE PRO_COD = :NEW.PRO_COD;
   END IF;
END;

-- TESTANDO
SELECT * FROM XPRODUTO WHERE PRO_COD =1
DROP TRIGGER TG_NOTA;
INSERT INTO XNOTA VALUES (99,1,SYSDATE,100);
INSERT INTO XITEMNOTA VALUES (99,1,3,1);
SELECT * FROM XPRODUTO WHERE PRO_COD =1
DELETE FROM XITEMNOTA WHERE NOT_NUM = 99 AND PRO_COD = 1;
SELECT * FROM XPRODUTO WHERE PRO_COD =1



